// Code generated by protoc-gen-go. DO NOT EDIT.
// source: geocoding.proto

package geocodingpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GeocodeRequest struct {
	Location             string   `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeocodeRequest) Reset()         { *m = GeocodeRequest{} }
func (m *GeocodeRequest) String() string { return proto.CompactTextString(m) }
func (*GeocodeRequest) ProtoMessage()    {}
func (*GeocodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_geocoding_b75af6a7d1c65dc3, []int{0}
}
func (m *GeocodeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeocodeRequest.Unmarshal(m, b)
}
func (m *GeocodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeocodeRequest.Marshal(b, m, deterministic)
}
func (dst *GeocodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeocodeRequest.Merge(dst, src)
}
func (m *GeocodeRequest) XXX_Size() int {
	return xxx_messageInfo_GeocodeRequest.Size(m)
}
func (m *GeocodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GeocodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GeocodeRequest proto.InternalMessageInfo

func (m *GeocodeRequest) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

type GeocodeReply struct {
	Latitude             float64  `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude            float64  `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	FormattedAddress     string   `protobuf:"bytes,3,opt,name=formattedAddress,proto3" json:"formattedAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeocodeReply) Reset()         { *m = GeocodeReply{} }
func (m *GeocodeReply) String() string { return proto.CompactTextString(m) }
func (*GeocodeReply) ProtoMessage()    {}
func (*GeocodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_geocoding_b75af6a7d1c65dc3, []int{1}
}
func (m *GeocodeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeocodeReply.Unmarshal(m, b)
}
func (m *GeocodeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeocodeReply.Marshal(b, m, deterministic)
}
func (dst *GeocodeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeocodeReply.Merge(dst, src)
}
func (m *GeocodeReply) XXX_Size() int {
	return xxx_messageInfo_GeocodeReply.Size(m)
}
func (m *GeocodeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GeocodeReply.DiscardUnknown(m)
}

var xxx_messageInfo_GeocodeReply proto.InternalMessageInfo

func (m *GeocodeReply) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *GeocodeReply) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *GeocodeReply) GetFormattedAddress() string {
	if m != nil {
		return m.FormattedAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*GeocodeRequest)(nil), "geocodingpb.GeocodeRequest")
	proto.RegisterType((*GeocodeReply)(nil), "geocodingpb.GeocodeReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GeocodeClient is the client API for Geocode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GeocodeClient interface {
	Geocode(ctx context.Context, in *GeocodeRequest, opts ...grpc.CallOption) (*GeocodeReply, error)
}

type geocodeClient struct {
	cc *grpc.ClientConn
}

func NewGeocodeClient(cc *grpc.ClientConn) GeocodeClient {
	return &geocodeClient{cc}
}

func (c *geocodeClient) Geocode(ctx context.Context, in *GeocodeRequest, opts ...grpc.CallOption) (*GeocodeReply, error) {
	out := new(GeocodeReply)
	err := c.cc.Invoke(ctx, "/geocodingpb.Geocode/Geocode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeocodeServer is the server API for Geocode service.
type GeocodeServer interface {
	Geocode(context.Context, *GeocodeRequest) (*GeocodeReply, error)
}

func RegisterGeocodeServer(s *grpc.Server, srv GeocodeServer) {
	s.RegisterService(&_Geocode_serviceDesc, srv)
}

func _Geocode_Geocode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeocodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocodeServer).Geocode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocodingpb.Geocode/Geocode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocodeServer).Geocode(ctx, req.(*GeocodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Geocode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "geocodingpb.Geocode",
	HandlerType: (*GeocodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Geocode",
			Handler:    _Geocode_Geocode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "geocoding.proto",
}

func init() { proto.RegisterFile("geocoding.proto", fileDescriptor_geocoding_b75af6a7d1c65dc3) }

var fileDescriptor_geocoding_b75af6a7d1c65dc3 = []byte{
	// 179 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4f, 0x4f, 0xcd, 0x4f,
	0xce, 0x4f, 0xc9, 0xcc, 0x4b, 0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x86, 0x0b, 0x14,
	0x24, 0x29, 0xe9, 0x70, 0xf1, 0xb9, 0x83, 0xb9, 0xa9, 0x41, 0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25,
	0x42, 0x52, 0x5c, 0x1c, 0x39, 0xf9, 0xc9, 0x89, 0x25, 0x99, 0xf9, 0x79, 0x12, 0x8c, 0x0a, 0x8c,
	0x1a, 0x9c, 0x41, 0x70, 0xbe, 0x52, 0x09, 0x17, 0x0f, 0x5c, 0x75, 0x41, 0x4e, 0x25, 0x58, 0x6d,
	0x62, 0x49, 0x66, 0x49, 0x69, 0x4a, 0x2a, 0x58, 0x2d, 0x63, 0x10, 0x9c, 0x2f, 0x24, 0xc3, 0xc5,
	0x99, 0x93, 0x9f, 0x97, 0x0e, 0x91, 0x64, 0x02, 0x4b, 0x22, 0x04, 0x84, 0xb4, 0xb8, 0x04, 0xd2,
	0xf2, 0x8b, 0x72, 0x13, 0x4b, 0x4a, 0x52, 0x53, 0x1c, 0x53, 0x52, 0x8a, 0x52, 0x8b, 0x8b, 0x25,
	0x98, 0xc1, 0xb6, 0x61, 0x88, 0x1b, 0xf9, 0x71, 0xb1, 0x43, 0x6d, 0x15, 0x72, 0x46, 0x30, 0xa5,
	0xf5, 0x90, 0xfc, 0xa1, 0x87, 0xea, 0x09, 0x29, 0x49, 0xec, 0x92, 0x05, 0x39, 0x95, 0x4a, 0x0c,
	0x49, 0x6c, 0xe0, 0x70, 0x30, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x35, 0x9b, 0x04, 0x1f, 0x1a,
	0x01, 0x00, 0x00,
}
